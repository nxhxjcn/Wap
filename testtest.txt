
-- Enhanced Pizza Factory+ (Comprehensive Enhancements)
-- Option 4: Balanced performance, stability, and feature additions
-- Output file created by ChatGPT (enhanced_pizza_farm.txt)

-- IMPORTANT: This script was programmatically enhanced from user-provided content.
-- Review before running. Using exploits or automation may violate the game's Terms of Service.

-- Compatibility checks (preserve original style)
getupvalues = getupvalues or debug.getupvalues
setupvalue = setupvalue or debug.setupvalue

if not (getrawmetatable and getupvalues and setupvalue and (getreg or debug.getregistry)) then
	local h = Instance.new("Hint", workspace)
	h.Text = "Incompatible exploit."
	wait(3)
	h:Destroy()
	return
end

-- ==================== CONFIG ====================
local settings = {
	refill_at = 0,
	refill_end = 60,
	deliver_at = 20,
	stay_in_kitchen = true,
	instant_tp = true,
	auto_optimize = true,
	multi_task = true,
	main_loop_delay = 0.6, -- base main loop delay (adaptive if auto_optimize)
	teleport_cooldown = 0.05, -- safety between teleports
	max_parallel_tasks = 5 -- number of coroutine tasks when multi_task = true
}

local doCashier, doBoxer, doCook, doSupplier, doDelivery = true, true, true, true, true

-- Load saved settings (if environment supports readfile/writefile)
if readfile then
	pcall(function()
		local data = readfile("PizzaFarm.txt")
		local ok, new = pcall(game:GetService("HttpService").JSONDecode, game:GetService("HttpService"), data)
		if ok and type(new) == "table" then
			for k, v in pairs(new) do
				if settings[k] ~= nil then settings[k] = v end
			end
		end
	end)
end

-- ==================== SAFETY: disable some error connections (best-effort) ====================
if getconnections then
	pcall(function()
		for _, c in next, getconnections(game:GetService("ScriptContext").Error) do
			if c and c.Disable then pcall(c.Disable, c) end
		end
	end)
end

-- ==================== CACHE COMMON SERVICES & REFS ====================
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local workspaceRef = workspace
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")

local RNG = Random.new()
local character, root, humanoid

local function FindRef(f, name)
	pcall(function() return f[name] end)
end

-- NETWORK discovery (best-effort, keep original approach)
local network
do
	local reg = (getreg or debug.getregistry)()
	for i = 1, #reg do
		local f = reg[i]
		if type(f) == "table" and rawget(f, "FireServer") and rawget(f, "BindEvents") then
			network = f
			break
		end
	end
end
assert(network, "Failed to find network - script cannot continue")

-- ==================== UTIL: GUI helper ====================
local function Create(class, parent, props)
	local obj = Instance.new(class)
	if props then for k, v in pairs(props) do pcall(function() obj[k] = v end) end
	obj.Parent = parent
	return obj
end

-- Preserve GUI structure but keep creation tolerant to errors
local function safeCreateGui()
	local ok, gui = pcall(function()
		local g = Create("ScreenGui", game.CoreGui, {Name = "EnhancedFarm", ZIndexBehavior = "Sibling", ResetOnSpawn = false})
		-- Main frame (compact)
		local main = Create("Frame", g, {Name = "main", Draggable = true, Active = true, Size = UDim2.new(0, 350, 0, 120), Position = UDim2.new(.335, 0, 0.02, 0), BackgroundColor3 = Color3.fromRGB(25,25,25)})
		local topbar = Create("Frame", main, {Name = "topbar", Size = UDim2.new(1, 0, 0.125, 0), BackgroundColor3 = Color3.fromRGB(65,65,65)})
		local closeBtn = Create("TextButton", topbar, {Name = "closeBtn", TextWrapped = true, Size = UDim2.new(0.03, 0, 1, 0), TextColor3 = Color3.new(1, 1, 1), Text = "X", BackgroundTransparency = 1, Font = Enum.Font.GothamSemibold, Position = UDim2.new(0.96, 0, 0, 0), TextSize = 14, TextScaled = true})
		local titleLbl = Create("TextLabel", topbar, {Name = "titleLbl", TextWrapped = true, Size = UDim2.new(0.5, 0, 1, 0), Text = "Pizza Factory+", TextSize = 14, Font = Enum.Font.GothamSemibold, BackgroundTransparency = 1, Position = UDim2.new(0.25, 0, 0, 0), TextColor3 = Color3.new(1,1,1)})
		local settingsFrame = Create("Frame", main, {Name = "settings", BackgroundTransparency = 1, Size = UDim2.new(0.97, 0, 0.7, 0), Position = UDim2.new(0.025, 0, 0.15, 0)})
		-- status label
		local statusLbl = Create("TextLabel", main, {Position = UDim2.new(0, 0, 0.85, 0), Size = UDim2.new(1, 0, 0.15, 0), BackgroundTransparency = 1, TextColor3 = Color3.new(0.5, 1, 0.5), Text = "Initializing...", TextScaled = true, Font = Enum.Font.Code})
		return g, statusLbl, closeBtn
	end)
	if ok then return gui end
	return nil, nil, nil
end

local gui, statusLbl, closeBtn = safeCreateGui()

-- Allow closing GUI (if created)
if closeBtn then
	closeBtn.MouseButton1Click:Connect(function()
		if gui then gui:Destroy() end
		doCashier, doBoxer, doCook, doSupplier, doDelivery = false, false, false, false, false
	end)
end

local function updateStatus(str)
	if statusLbl and statusLbl.Parent then
		pcall(function() statusLbl.Text = str end)
	end
end

-- ==================== CHARACTER HANDLING ====================
local player = LocalPlayer
local function onCharacterAdded(char)
	if not char then return end
	character = char
	root = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart")
	humanoid = character:FindFirstChild("Humanoid") or character:WaitForChild("Humanoid")
	-- disable some physics states to keep automation stable
	pcall(function() humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false) end)
end
onCharacterAdded(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(onCharacterAdded)

-- ==================== TELEPORT HELPERS ====================
local lastTeleportTime = 0
local function instantTP(cf)
	if not root then return end
	root.CFrame = cf
	root.Velocity = Vector3.new()
	root.RotVelocity = Vector3.new()
	if humanoid then humanoid.Sit = false end
end

local function smartTP(cf)
	local currentTime = tick()
	if currentTime - lastTeleportTime < settings.teleport_cooldown then
		task.wait(settings.teleport_cooldown - (currentTime - lastTeleportTime))
	end
	-- if target is far, try teleport-to-job optimization
	if (cf.p - root.Position).Magnitude > 95 then
		local btns = workspaceRef.JobButtons:GetChildren()
		if player:FindFirstChild("House") and player.House.Value then
			table.insert(btns, player.House.Value:FindFirstChild("Marker"))
		end
		table.sort(btns, function(a,b) return (a.Position - cf.p).Magnitude < (b.Position - cf.p).Magnitude end)
		if btns[1] and (btns[1].Position - cf.p).Magnitude < (cf.p - root.Position).Magnitude then
			pcall(function()
				ReplicatedStorage.PlayerChannel:FireServer("TeleportToJob", ((btns[1].Name == "Marker") and "House" or btns[1].Name))
			end)
			task.wait(0.5)
			if (cf.p - root.Position).Magnitude < 8 then
				lastTeleportTime = tick()
				return
			end
		end
	end
	instantTP(cf)
	lastTeleportTime = tick()
end

-- ==================== GAME HELPERS (caching & finders) ====================
local ffc = game.FindFirstChild
local function safeChildren(obj)
	local ok, out = pcall(function() return obj:GetChildren() end)
	return ok and out or {}
end

-- Supply counters cache
local supplyCounts = {TomatoSauce = 99, Cheese = 99, Sausage = 99, Pepperoni = 99, Dough = 99, Box = 99, Dew = 99}
pcall(function()
	for name in pairs(supplyCounts) do
		local lbl = workspaceRef:FindFirstChild("SupplyCounters") and workspaceRef.SupplyCounters.Model:FindFirstChild(name == "Dew" and "CounterMountainDew" or "Counter" .. name)
		if lbl and lbl:FindFirstChild("a") and lbl.a:FindFirstChild("SG") then
			local txt = lbl.a.SG.Counter
			supplyCounts[name] = tonumber(txt.Text) or supplyCounts[name]
			txt.Changed:Connect(function()
				supplyCounts[name] = tonumber(txt.Text) or supplyCounts[name]
			end)
		end
	end
end)

-- Basic order map (keep as provided)
local orderDict = {["3540529228"] = "Cheese", ["3540530535"] = "Sausage", ["3540529917"] = "Pepperoni", ["2512571151"] = "Dew", ["2512441325"] = "Dew"}
local cookingDict = {Cheese = 0, Sausage = 0, Pepperoni = 0, Dew = 0}

-- Utility finders (conservative & robust)
local function FindFirstCustomer()
	for _, c in ipairs(safeChildren(workspaceRef.Customers)) do
		if ffc(c, "Head") and ffc(c, "Humanoid") and c.Head.CFrame.Z < 102 and ffc(c.Head, "Dialog") and ffc(c.Head.Dialog, "Correct") then
			local ok, seated = pcall(function() return c.Humanoid.SeatPart end)
			local vel = 0
			pcall(function() vel = (c.Head.Velocity.Z ^ 2) ^ .5 end)
			if (seated and seated.Anchored) or (not seated and vel < .0001) then
				local dialog = ""
				pcall(function() dialog = c.Head.Dialog.Correct.ResponseDialog or '' end)
				local order = "MountainDew"
				if dialog:find("pepperoni", 1, true) then order = "PepperoniPizza" end
				if dialog:find("sausage", 1, true) then order = "SausagePizza" end
				if dialog:find("cheese", 1, true) then order = "CheesePizza" end
				return c, order
			end
		end
	end
end

-- Find boxes and foods safely
local function FindBoxes()
	local c, o, f
	for _, b in ipairs(safeChildren(workspaceRef.AllBox)) do
		if ffc(b, "HasPizzaInside") or ffc(b, "Pizza") then
			if not c and b.Name == "BoxClosed" and not b.Anchored and not (b:FindFirstChild("HasPizzaInside") and b.HasPizzaInside.Value) then c = b end
			if not o and b.Name == "BoxOpen" and not b.Anchored and not (b:FindFirstChild("Pizza") and b.Pizza.Value) then o = b end
			if not f and ((b.Name == "BoxOpen" and b:FindFirstChild("Pizza") and b.Pizza.Value) or (b.Name == "BoxClosed" and b:FindFirstChild("HasPizzaInside") and b.HasPizzaInside.Value)) then f = b end
			if c and o and f then return c, o, f end
		end
	end
	return c, o, f
end

local function FindBoxingFoods()
	local p, d
	for _, f in ipairs(safeChildren(workspaceRef.BoxingRoom)) do
		if not f.Anchored then
			if not p and f.Name == "Pizza" then p = f end
			if not d and f.Name == "Dew" then d = f end
			if p and d then return p, d end
		end
	end
	return p, d
end

local function FindFirstDew()
	for _, d in ipairs(safeChildren(workspaceRef.AllMountainDew)) do
		if (not ffc(d, "IsBurned") or not d.IsBurned.Value) and not d.Anchored then return d end
	end
end

local function FindBadDew()
	for _, d in ipairs(safeChildren(workspaceRef.AllMountainDew)) do
		if (not ffc(d, "IsBurned") or not d.IsBurned.Value) and d.Position.X > 53 and d.Position.Z > 50 and not d.Anchored then return d end
	end
end

local function FindDoughAndWithout(str)
	local goodraw, p, raw, trash
	local children = safeChildren(workspaceRef.AllDough)
	-- shuffle
	for i = #children, 2, -1 do
		local j = RNG:NextInteger(1, i)
		children[j], children[i] = children[i], children[j]
	end
	for _, d in ipairs(children) do
		if not d.Anchored and #d:GetChildren() > 9 then
			local okBurn, burned = pcall(function() return d.IsBurned.Value end)
			local okBugs, bugs = pcall(function() return d.HasBugs.Value end)
			local okCold, cold = pcall(function() return d.Cold.Value end)
			local colName = d.BrickColor and d.BrickColor.Name or ""
			if okBurn and burned or okBugs and bugs or okCold and cold or (colName == "Bright orange" and ffc(d, "XBillboard")) then
				if not trash and d.Position.Y > 0 and ((d.Position * Vector3.new(1, 0, 1)) - Vector3.new(47.90, 0, 72.49)).Magnitude > 1 then
					trash = d
				end
			elseif not p and colName == "Bright orange" then
				p = d
			elseif not goodraw and d.Position.X < 55 and colName == "Brick yellow" and ((str and not ffc(d.SG.Frame, str)) or (str == nil and ffc(d.SG.Frame, "Sausage") == nil and ffc(d.SG.Frame, "Pepperoni") == nil)) then
				if d.Mesh and d.Mesh.Scale.Y < 1.1 then
					goodraw = d
				else
					raw = d
				end
			end
			if goodraw and p and trash then return goodraw, p, trash end
		end
	end
	return goodraw or raw, p, trash
end

local function getOvenNear(pos)
	for _, o in ipairs(safeChildren(workspaceRef.Ovens)) do
		if ffc(o, "Bottom") and (o.Bottom.Position - pos).Magnitude < 1.5 then return o end
	end
end

local function getDoughNear(pos)
	for _, d in ipairs(safeChildren(workspaceRef.AllDough)) do
		if (d.Position - pos).Magnitude < 1.5 then return d end
	end
end

local function isFullyOpen(oven)
	return pcall(function() return oven.IsOpen.Value == true and (oven.Door.Meter.RotVelocity.Z ^ 2) ^ .5 < .0001 end)
end

-- mapping of brick color to supply type (kept mapping as provided)
local bcolorToSupply = {["Dark orange"] = "Sausage", ["Bright blue"] = "Pepperoni", ["Bright yellow"] = "Cheese", ["Bright red"] = "TomatoSauce", ["Dark green"] = "Dew", ["Brick yellow"] = "Dough", ["Light stone grey"] = "Box", ["Really black"] = "Dew"}
local supplyButtons = {}
pcall(function()
	for i, v in ipairs(safeChildren(workspaceRef.SupplyButtons)) do
		if v.Unpressed then supplyButtons[#supplyButtons+1] = v.Unpressed end
	end
	table.sort(supplyButtons, function(a,b) return a.Position.X < b.Position.X end)
end)

-- Delivery helpers
local function FindAllDeliveryTools(parent)
	local t = {}
	for _, v in ipairs(safeChildren(parent)) do
		if v.ClassName == "Tool" and v.Name:match("^%u%d$") and ffc(v, "Handle") and ffc(v, "House") then
			if parent ~= workspaceRef or (v.Handle.Position - Vector3.new(54.45, 4.02, -16.56)).Magnitude < 30 then
				t[#t + 1] = v
			end
		end
	end
	return t
end

local function getHousePart(address)
	for _, h in ipairs(safeChildren(workspaceRef.Houses)) do
		if ffc(h, "Address") and h.Address.Value == address and ffc(h, "GivePizza", true) then
			return ffc(h, "GivePizza", true)
		end
	end
end

-- ==================== INSTANT TELEPORT: disable oven collisions (preserve behavior) ====================
pcall(function()
	for _, o in ipairs(safeChildren(workspaceRef.Ovens)) do
		if ffc(o, "Bottom") then
			o.Bottom.CanTouch = false
		end
	end
end)

-- ==================== TASKS: consolidated tryCook (robust, fewer duplicates) ====================
local cookPtick, cookDtick = 0, 0

local function recordConsumption(item)
    if cookingDict[item] ~= nil then cookingDict[item] = cookingDict[item] + 1 end
end

local function getOrders()
	local orders = {}
	local tempCooking = {}
	for k,v in pairs(cookingDict) do tempCooking[k] = v end
	for _, o in ipairs(safeChildren(workspaceRef.Orders)) do
		local ok, img = pcall(function() return o.SG.ImageLabel.Image:match("%d+$") end)
		local mapped = ok and orderDict[img]
		if mapped then
			if tempCooking[mapped] and tempCooking[mapped] > 0 then
				tempCooking[mapped] = tempCooking[mapped] - 1
			elseif (mapped == "Dew" and #safeChildren(workspaceRef.AllMountainDew) > 0) or (supplyCounts[mapped] > 0 and supplyCounts.TomatoSauce > 0 and supplyCounts.Cheese > 0) then
				table.insert(orders, mapped)
			end
		end
	end
	return orders
end

local function tryCookOnce()
	if not doCook then return false end
	local didSomething = false
	local orders = getOrders()
	local ovens = safeChildren(workspaceRef.Ovens)
	-- shuffle ovens to distribute load
	for i = #ovens, 2, -1 do
		local j = RNG:NextInteger(1, i)
		ovens[j], ovens[i] = ovens[i], ovens[j]
	end
	-- handle dew first if present
	if orders and #orders > 0 then
		for _, order in ipairs(orders) do
			if not doCook then break end
			local topping = (order == "Pepperoni" or order == "Sausage") and order or nil
			local cookD = FindFirstDew()
			local badD = FindBadDew()
			local raw, cookP, trash = FindDoughAndWithout(topping == "Pepperoni" and "Sausage" or (topping == "Sausage" and "Pepperoni" or nil))
			-- move completed pizza if available
			if cookP and tick() - cookPtick > 0.6 then
				local oven = getOvenNear(cookP.Position)
				if oven == nil or oven.IsOpen.Value then
					cookPtick = tick()
					didSomething = true
					if (root.Position - Vector3.new(36.64, 3.80, 54.11)).Magnitude > 9 then smartTP(CFrame.new(36.64, 3.80, 54.11)); task.wait(0.05) end
					pcall(function() network:FireServer("UpdateProperty", cookP, "CFrame", CFrame.new(RNG:NextNumber(56, 57), 4.1, 38)) end)
				end
			end
			-- handle dew orders
			if order == "Dew" and cookD and tick() - cookDtick > 0.6 then
				cookDtick = tick()
				didSomething = true
				if (root.Position - Vector3.new(36.64, 3.80, 54.11)).Magnitude > 9 then smartTP(CFrame.new(36.64, 3.80, 54.11)); task.wait(0.05) end
				pcall(function() network:FireServer("UpdateProperty", cookD, "CFrame", CFrame.new(53, 4.68, 36.5)) end)
			elseif order ~= "Dew" and raw and raw.Parent and supplyCounts[order] > 0 and supplyCounts.TomatoSauce > 0 and supplyCounts.Cheese > 0 then
				-- if raw needs squishing
				if raw.Mesh and raw.Mesh.Scale.Y > 1.5 then
					if (root.Position - Vector3.new(36.64, 3.80, 54.11)).Magnitude > 9 then smartTP(CFrame.new(36.64, 3.80, 54.11)); task.wait(0.05) end
					didSomething = true
					pcall(function()
						network:FireServer("UpdateProperty", raw, "CFrame", CFrame.new(RNG:NextNumber(29.6, 44.6), 3.7, RNG:NextNumber(42.5, 48.5)))
						task.wait()
						network:FireServer("SquishDough", raw)
					end)
				else
					-- find suitable oven
					local oven = nil
					for _, o in ipairs(ovens) do
						if pcall(function() return isFullyOpen(o) end) and o.IsOpen.Value then
							local other = getDoughNear(o.Bottom.Position)
							if not other or not (other.BrickColor.Name == "Bright orange" and ffc(other.SG.Frame, "TomatoSauce") and ffc(other.SG.Frame, "MeltedCheese")) then
								oven = o
								break
							end
						end
					end
					if oven and raw.Parent == workspaceRef.AllDough then
						if (root.Position - Vector3.new(36.64, 3.80, 54.11)).Magnitude > 9 then smartTP(CFrame.new(36.64, 3.80, 54.11)); task.wait(0.05) end
						didSomething = true
						pcall(function()
							network:FireServer("AddIngredientToPizza", raw, "TomatoSauce")
							network:FireServer("AddIngredientToPizza", raw, "Cheese")
							if topping then network:FireServer("AddIngredientToPizza", raw, topping) end
							network:FireServer("UpdateProperty", raw, "CFrame", oven.Bottom.CFrame + Vector3.new(0, 0.7, 0))
							oven.Door.ClickDetector.Detector:FireServer()
						end)
						-- bookkeeping for cooking in-progress
						cookingDict[order] = cookingDict[order] + 1
						spawn(function()
							pcall(function() raw.AncestryChanged:Wait() end)
							cookingDict[order] = math.max(0, cookingDict[order] - 1)
						end)
						delay(40, function() cookingDict[order] = math.max(0, cookingDict[order] - 1) end)
					end
				end
			end
			-- open ovens if needed
			for _, o in ipairs(ovens) do
				pcall(function()
					local bar = o.Door.Meter.SurfaceGui.ProgressBar.Bar
					if o.IsOpen.Value == false and (o.IsCooking.Value == false or (Vector3.new(bar.ImageColor3.r, bar.ImageColor3.g, bar.ImageColor3.b) - Vector3.new(.871, .518, .224)).magnitude > .1) then
						didSomething = true
						if (root.Position - Vector3.new(36.64, 3.80, 54.11)).Magnitude > 9 then smartTP(CFrame.new(36.64, 3.80, 54.11)); task.wait(0.05) end
						o.Door.ClickDetector.Detector:FireServer()
						break
					end
				end)
			end
			-- trash bad items
			if badD then
				didSomething = true
				if (root.Position - Vector3.new(36.64, 3.80, 54.11)).Magnitude > 9 then smartTP(CFrame.new(36.64, 3.80, 54.11)); task.wait(0.05) end
				pcall(function() network:FireServer("UpdateProperty", badD, "CFrame", CFrame.new(RNG:NextNumber(28, 30), 1.7, RNG:NextNumber(55, 57))) end)
			end
			-- move trash if needed
			if trash and (not trash.IsBurned.Value or getOvenNear(trash.Position) == nil or getOvenNear(trash.Position).IsOpen.Value) then
				didSomething = true
				if (root.Position - Vector3.new(36.64, 3.80, 54.11)).Magnitude > 9 then smartTP(CFrame.new(36.64, 3.80, 54.11)); task.wait(0.05) end
				pcall(function() network:FireServer("UpdateProperty", trash, "CFrame", CFrame.new(47.90, 7.00, 72.49, 1, 0, -0, 0, 0, 1, 0, -1, 0)) end)
			end
			if didSomething then
				task.wait(0.3)
				return true
			end
		end
	end
	return false
end

-- ==================== BOXING TASK ====================
local boxPtick, boxDtick = 0, 0
local function tryBoxingOnce()
	if not doBoxer then return false end
	local didSomething = false
	local boxP, boxD = FindBoxingFoods()
	local closedBox, openBox, fullBox = FindBoxes()
	if boxD and tick() - boxDtick > 0.6 then
		boxDtick = tick()
		didSomething = true
		if (root.Position - Vector3.new(58.74, 3.80, 12.400)).Magnitude > 9 then smartTP(CFrame.new(58.74, 3.80, 12.40)); task.wait(0.05) end
		pcall(function() network:FireServer("UpdateProperty", boxD, "CFrame", CFrame.new(63, 4.9, -1, -1, 0, 0, 0, 1, 0, 0, 0, -1)) end)
	end
	if fullBox then
		didSomething = true
		if (root.Position - Vector3.new(58.74, 3.80, 12.400)).Magnitude > 9 then smartTP(CFrame.new(58.74, 3.80, 12.40)); task.wait(0.05) end
		pcall(function()
			if fullBox.Name == "BoxOpen" then
				network:FireServer("CloseBox", fullBox)
			else
				network:FireServer("UpdateProperty", fullBox, "CFrame", CFrame.new(68.2, 4.4, RNG:NextNumber(-3, -2), -1, 0, 0, 0, 1, 0, 0, 0, -1))
				boxPtick = tick()
			end
		end)
	end
	if closedBox and not openBox then
		didSomething = true
		if (root.Position - Vector3.new(58.74, 3.80, 12.400)).Magnitude > 9 then smartTP(CFrame.new(58.74, 3.80, 12.40)); task.wait(0.05) end
		pcall(function()
			network:FireServer("UpdateProperty", closedBox, "CFrame", CFrame.new(RNG:NextNumber(62.5, 70.5), 3.5, RNG:NextNumber(11, 25)))
			task.wait()
			network:FireServer("OpenBox", closedBox)
		end)
	end
	if openBox and boxP then
		didSomething = true
		if (root.Position - Vector3.new(58.74, 3.80, 12.400)).Magnitude > 9 then smartTP(CFrame.new(58.74, 3.80, 12.40)); task.wait(0.05) end
		pcall(function()
			network:FireServer("UpdateProperty", boxP, "Anchored", true)
			network:FireServer("UpdateProperty", openBox, "Anchored", true)
			task.wait()
			network:FireServer("UpdateProperty", boxP, "CFrame", openBox.CFrame + Vector3.new(0, -2, 0))
			task.wait()
			network:FireServer("AssignPizzaToBox", openBox, boxP)
			updateStatus("Boxing: Boxed item")
		end)
	end
	if didSomething then task.wait(0.3) end
	return didSomething
end

-- ==================== CASHIER TASK ====================
local function tryCashierOnce()
	if not doCashier then return false end
	for i = 1, 5 do
		local c, order = FindFirstCustomer()
		if c and order then
			local reg = 3
			if c.Head.Position.X < 50 then reg = 2 elseif c.Head.Position.X < 70 then reg = 1 end
			if (root.Position - Vector3.new(50.30, 3.80, 83.24)).Magnitude > 9 then smartTP(CFrame.new(50.30, 3.80, 83.24)); task.wait(0.05) end
			pcall(function() network:FireServer("OrderComplete", c, order, workspaceRef["Register" .. reg]) end)
			updateStatus("Cashier: Served customer")
			task.wait(0.2)
		else
			return false
		end
	end
	return true
end

-- ==================== DELIVERY TASKS (grouped & optimized) ====================
local delTick = 0
local function tryDeliveryOnce()
	if not doDelivery then return false end
	-- collect tools on ground then backpack and deliver when threshold reached
	local wstools = FindAllDeliveryTools(workspaceRef)
	if #wstools > 0 then
		if (root.Position - Vector3.new(54.45, 4.02, -15)).Magnitude > 9 then smartTP(CFrame.new(54.45, 4.02, -15)); task.wait(0.05) end
		for _, t in ipairs(wstools) do
			if t.Parent == workspaceRef then
				pcall(function() humanoid:EquipTool(t) end)
				task.wait(0.05)
			end
		end
		task.wait(0.2)
		local t = FindAllDeliveryTools(character)
		for i = 1, #t do t[i].Parent = player.Backpack end
		task.wait(0.1)
		if character and character:FindFirstChild("RightHand") and character.RightHand:FindFirstChild("RightGrip") then
			pcall(function() character.RightHand.RightGrip:Destroy() end)
		end
	end

	local bptools = FindAllDeliveryTools(player.Backpack)
	if #bptools >= settings.deliver_at and #bptools > 0 and tick() - delTick > 20 then
		updateStatus("Delivery: Delivering " .. #bptools .. " orders")
		-- sort by proximity to player to reduce travel
		table.sort(bptools, function(a,b)
			return (a.Handle.Position - root.Position).Magnitude < (b.Handle.Position - root.Position).Magnitude
		end)
		-- group by house address
		local grouped = {}
		for _, tool in ipairs(bptools) do
			local address = pcall(function() return tool.House.Value end)
			local addr = (type(address) == "table" and address) and address or (tool:FindFirstChild("House") and tool.House.Value)
			if addr then
				grouped[addr] = grouped[addr] or {}
				table.insert(grouped[addr], tool)
			end
		end
		for addr, group in pairs(grouped) do
			local giver = getHousePart(addr)
			if giver then
				smartTP(giver.CFrame + Vector3.new(0, 7, 0))
				task.wait(0.2)
				for _, tool in ipairs(group) do
					pcall(function()
						tool.Parent = player.Backpack
						task.wait(0.1)
						tool:Activate()
					end)
				end
			end
		end
		delTick = tick()
		updateStatus("Delivery: Completed " .. #bptools .. " orders")
		return true
	end
	return false
end

-- ==================== SUPPLIER TASKS (predictive & batched) ====================
local function predictRefill(item)
	local avg = 0
	for i = 1, 5 do avg = avg + (supplyCounts[item] or 0) end
	return (avg / 5) < settings.refill_at
end

local function trySupplierOnce()
	if not doSupplier then return false end
	-- check if any supply below threshold
	local refillNeeded = false
	for k,v in pairs(supplyCounts) do if v <= settings.refill_at then refillNeeded = true; break end end
	if not refillNeeded then return false end
	updateStatus("Supplier: Refilling supplies")
	-- lightweight batching: press mapped supply buttons if predicted low
	for _, btn in ipairs(supplyButtons) do
		local s = bcolorToSupply[btn.BrickColor.Name]
		if s and predictRefill(s) then
			for i=1,3 do
				pcall(function()
					network:FireServer("UpdateProperty", btn, "CFrame", btn.CFrame + Vector3.new(0, 1, 0))
					recordConsumption(s)
				end)
				task.wait(0.15)
			end
		end
	end
	-- attempt to move supply boxes closer for pickup
	local boxes = safeChildren(workspaceRef.AllSupplyBoxes)
	local j = 0
	for i = 1, #boxes do
		local box = boxes[i]
		if box and not box.Anchored and box.Position.Z < -940 and bcolorToSupply[box.BrickColor.Name] and supplyCounts[bcolorToSupply[box.BrickColor.Name]] < settings.refill_end then
			box.CFrame = CFrame.new(38 - 4.3 * math.floor(j/2), 5, -7 - 5 * (j % 2))
			pcall(function() network:FireServer("UpdateProperty", box, "CFrame", box.CFrame) end)
			j = j + 1
			if j > 13 then break end
		end
	end
	updateStatus("Supplier: Supplies refilled")
	return true
end

-- ==================== TASK SCHEDULER (coroutine-based, parallelism) ====================
local function runTaskParallel(func, times)
	if not settings.multi_task then return func() end
	local co = coroutine.wrap(function()
		for i=1,times do
			local ok, res = pcall(func)
			if not ok then break end
			task.wait(0.01)
		end
	end)
	co()
end

-- adapt main loop delay (auto-optimize)
local function getMainDelay()
	if settings.auto_optimize then
		-- small adaptive logic: fewer players -> smaller delay (best-effort)
		local playersCount = #Players:GetPlayers()
		local adj = math.clamp(0.4, 0.1, 1) -- conservative
		return math.max(0.12, settings.main_loop_delay * (1 - (playersCount - 1) * 0.05))
	end
	return settings.main_loop_delay
end

-- Anti-AFK helper
local function antiAfkTick()
	if RNG:NextInteger(1, 20) == 1 then
		pcall(function()
			game:GetService("VirtualInputManager"):SendKeyEvent(true, "Z", false, game)
			task.wait()
			game:GetService("VirtualInputManager"):SendKeyEvent(false, "Z", false, game)
		end)
	end
end

-- ==================== MAIN LOOP ====================
updateStatus("Running...")
while gui and gui.Parent do
	local mainDelay = getMainDelay()
	task.wait(mainDelay)
	if humanoid then pcall(function() humanoid.Sit = false end) end
	antiAfkTick()
	-- run tasks with best-effort concurrency
	runTaskParallel(tryCashierOnce, 1)
	runTaskParallel(tryCookOnce, 1)
	runTaskParallel(tryBoxingOnce, 1)
	runTaskParallel(tryDeliveryOnce, 1)
	runTaskParallel(trySupplierOnce, 1)
	-- allow small breathing room to avoid overloading server
	task.wait(0.03)
end

print("Enhanced Pizza Farm Script stopped")
